---
title: "『RustによるWebアプリケーション開発 設計からリリース・運用まで』を読んだ"
tags:
  - "rust"
  - "読書ログ"

description: ""
date: 2025-12-22T00:13:06+09:00
author: "kyu08"
authorTwitter: "kyu08_"
draft: false
showFullContent: false
readingTime: true
hideComments: false
color: ""
cover: "cover.png"
---

『RustによるWebアプリケーション開発 設計からリリース・運用まで』を読んだので学びを書こうと思う。

## モチベーション
Rustという言語の開発体験がかなり好きでRustでサーバーサイドを書くのがどんな感じなのか純粋に気になっていたので読んでみた。（筆者がサーバーサイドの開発でガッツリ書いたことがあるのはGoのみというバックグラウンド）

## 本書の概要
本書はRustで蔵書管理アプリケーションのサーバーサイドを実装しながらRustでのWebアプリケーション開発の仕方を学ぶことができる本。

ただ動くものを作る、というよりは業務の実際のサーバーサイドの開発でよく出くわす課題をRustでどう開発するかが豊富に紹介されていた。(DIやエラーハンドリングなど)

設計面ではレイヤードアーキテクチャを採用しており、レイヤー間の責務などが考慮された設計になっている。その意味でも実務での開発に近い内容になっていると言えるかもしれない。

あとはステップごとのコード差分が丁寧に書かれているので、本書に従って実装を進めるとWeb Serverの実装が出来上がる（はず）。[^1]

## 学び
- コンパイル時間短縮の工夫
    - アプリケーションを複数のクレートを分割することで変更があったクレートだけ再コンパイルすればよくなるためコンパイル時間が短縮できる。
    - たとえば本書ではレイヤードアーキテクチャのレイヤーごとにクレートを分割していた。
- Web開発で有用なクレート
    - [`derive_new`](https://crates.io/crates/derive-new): `new`関数を実装してくれる。デフォルト値の設定などもできる模様。
    - [`serde`](https://crates.io/crates/serde): 言わずと知れたシリアライズ/デシリアライズのためのクレート。
    - [`sqlx`](https://crates.io/crates/sqlx): SQLを型安全に扱うことができる。
- エラーハンドリングの方法
    - クライアントに返すエラーはthiserrorで定義し、それ以外のエラーはanyhowを使って表現する。
- RustでどうDIを実装すべきか
    - ジェネリクスを用いてDIするパターン（静的ディスパッチ）
        - 記述量が増える
        - 動的ディスパッチと比較するとパフォーマンスが高い
    - トレイトオブジェクト（`dyn <トレイト名>`）を利用するパターン（動的ディスパッチ）
        - 記述量が減る
        - 静的ディスパッチと比較するとパフォーマンス面で不利
        - 本書ではWeb開発において動的ディスパッチのコストが問題になることは少ないことを理由にこちらを採用していた。

## 実際にRustでWeb Serverを書いてみた感想（主にGoとの比較）
※なお、筆者のRustスキルは趣味レベルなのでRustを深く理解したうえでの感想ではありません。間違っている点や他の重要な観点などがある可能性があります。また、主には個人的な考えのスナップショットを自分用に残す目的で書いているので説明を端折っている箇所がある可能性があります。

### ポジ
<!-- TODO: この辺具体的なコードを書く -->
- enumやパターンマッチ等を使って仕様をスマートに書ける。
- null安全なので他の言語のnull相当の概念を型安全に扱うことができる。
- 変数がデフォルトでimmutableなので、mutableな変数を目立たせやすいし、自然とimmutableなコードが書きやすい。
- あらゆるシンボルがデフォルトでprivateなのでカプセル化するようなコードが若干書きやすい。（意識的に`pub`を付けなければprivateになってくれる点で強い理由がなければprivateになりやすくなる、と考えている）

### ネガ
- コンパイル時間が長い
- Goに慣れているとRustのマクロやアトリビュートが若干黒魔術的に感じる。これらに慣れるまでは認知負荷が高そう。こういうのとか。（『RustによるWebアプリケーション開発 設計からリリース・運用まで』より引用）
    ```rust
    #[derive(Error, Debug)]
    pub enum AppError {
        #[error("{0}")]
        UnprocessableEntity(String),
        #[error("{0}")]
        EntityNotFound(String),
        #[error("{0}")]
        ValidationError(#[from] garde::Report),
        #[error("トランザクションを実行できませんでした。")]
        TransactionError(#[source] sqlx::Error),
        #[error("データベース処理実行中にエラーが発生しました。")]
        SpecificOperationError(#[source] sqlx::Error),
        #[error("No rows affected: {0}")]
        NoRowsAffectedError(String),
        #[error("{0}")]
        KeyValueStoreError(#[from] redis::RedisError),
        #[error("{0}")]
        BcryptError(#[from] bcrypt::BcryptError),
        #[error("{0}")]
        ConvertToUuidError(#[from] uuid::Error),
        #[error("ログインに失敗しました")]
        UnauthenticatedError,
        #[error("認可情報が誤っています")]
        UnauthorizedError,
        #[error("許可されていない操作です")]
        ForbiddenOperation,
        #[error("{0}")]
        ConversionEntityError(String),
    }
    ```
- コンパイル時間短縮のためにcrate分割が推奨されているが、依存関係の増減があるたびに`Cargo.toml`を手書きで編集しないといけないのが若干面倒
    - もしかしたらコードアクション等、エディタの支援が得られるのかもしれないがそこまで調べられていない。
- DIが若干面倒
    - Goならinterface使うだけなので楽
- 非同期処理
    - これもRustの非同期処理の仕組みへの理解[^2]が大変浅いのであまり具体的に書けないが、自分の現状のRustスキルだとGoに比べて意図通りに動く非同期処理を書くのに数倍時間がかかる。

## まとめ
本書を読むまではRustがWebサーバーサイド開発の銀の弾丸、とまでは言わないもののかなりいい選択肢の1つのように思えていた。主に型の表現力のお陰でドメインがうまく表現できたり、所有権などの言語機能や発達したリンターによって内部品質を高く保つことができ、その結果開発生産性が高まると考えていた。

<!-- TODO: [^3]の内容を削って表にかくのがいいかなあ -->
しかし実際に本書でRustでサーバーを書いてみるとGoのシンプルさ、手軽さの良さを改めて認識した。[^3]

少なくとも今の自分のRustスキルだと（Rustの表現力が高いとはいえ）Goを採用したほうが長期的にも開発効率が高そうだと感じている。

<!-- これまではRustを導入することで（Rustに慣れさえすれば）開発生産性が長期的には大きく向上するのでは、と思っていたが今は手放しにそう考えることはできなくなった。 -->

結果はどうであれ実際にRustでサーバーを書くのがどんな感じなのかを知ることが本書を読んだ目的だったので解像度を高めることができてよかった。[^4]

[^1]: 5章途中までしかやっていないので「はず」と書いている。
[^2]: あるいは単にコンピュータの仕組みへの理解が浅いとも言えるのかもしれない。
[^3]: 言い換えると、（自分ひとりまたは自分の身の周りのエンジニアと一緒に開発をするのであれば）要件にもよるがシンプルなWebアプリケーションであれば基本的にはGoの方がビジネス成果を継続的に出しやすそうだと感じた。例えばパフォーマンスが極めて重要だったり、サーバーコスト圧縮のビジネスメリットが極めて大きかったり、ドメインロジックが超複雑だったりする場合は選択肢になるかもしれないなと思っている。あとはRustに精通したメンバーの割合がかなり多く、Goよりも組織的に（かつ継続的に）生産性が高まりそうなどの環境であればRustが有利になるかもしれない。
[^4]: もちろんもっとDeep Diveしたら違う感想を得られるのかも知れないが、あくまで今時点の自分の感想としてはnot for meだなという感じ。
