<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CQRS on blog.kyu08.com</title>
    <link>https://blog.kyu08.com/pr-285/tags/cqrs/</link>
    <description>Recent content in CQRS on blog.kyu08.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>blog.kyu08.com</copyright>
    <lastBuildDate>Mon, 12 Jan 2026 00:27:58 +0900</lastBuildDate><atom:link href="https://blog.kyu08.com/pr-285/tags/cqrs/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>『CQRS Documents by Greg Young』を読んだ</title>
      <link>https://blog.kyu08.com/pr-285/posts/cqrs-documents-by-greg-young/</link>
      <pubDate>Mon, 12 Jan 2026 00:27:58 +0900</pubDate>
      
      <guid>https://blog.kyu08.com/pr-285/posts/cqrs-documents-by-greg-young/</guid>
      <description>CQRSに興味があったのでGreg Young氏のCQRS Documentsを読んでみた。 https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdfhttps://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf CQRSに興味を持ったきっかけ ドメイン層のメンテナ</description>
      <content>&lt;p&gt;CQRSに興味があったのでGreg Young氏の&lt;a href=&#34;https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf&#34; target=&#34;_blank&#34; &gt;CQRS Documents&lt;/a&gt;を読んでみた。&lt;/p&gt;
&lt;p&gt;&lt;div class=&#34;blogcard&#34; data-url=&#34;https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf&#34; data-auto-fetch=&#34;false&#34;&gt;
  &lt;a href=&#34;https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34; class=&#34;blogcard-link&#34;&gt;&lt;div class=&#34;blogcard-thumbnail blogcard-thumbnail-placeholder&#34;&gt;
      &lt;svg xmlns=&#34;http://www.w3.org/2000/svg&#34; viewBox=&#34;0 0 24 24&#34; fill=&#34;none&#34; stroke=&#34;currentColor&#34; stroke-width=&#34;2&#34; stroke-linecap=&#34;round&#34; stroke-linejoin=&#34;round&#34;&gt;
        &lt;path d=&#34;M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71&#34;&gt;&lt;/path&gt;
        &lt;path d=&#34;M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71&#34;&gt;&lt;/path&gt;
      &lt;/svg&gt;
    &lt;/div&gt;&lt;div class=&#34;blogcard-content&#34;&gt;
      &lt;div class=&#34;blogcard-title&#34;&gt;https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf&lt;/div&gt;&lt;div class=&#34;blogcard-url&#34;&gt;https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf&lt;/div&gt;
    &lt;/div&gt;
  &lt;/a&gt;
&lt;/div&gt;
&lt;/p&gt;
&lt;h2 id=&#34;cqrsに興味を持ったきっかけ&#34;&gt;CQRSに興味を持ったきっかけ&lt;/h2&gt;
&lt;p&gt;ドメイン層のメンテナビリティの重要性を感じる中で、ドメイン層は書き込み系の振る舞いだけを担い、読み取り系の責務は別のモジュールに移譲してしまった方がドメイン層をシンプルに保てて良いのではないかと考えるようになった。&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;それってCQRSってやつじゃね？と思ったのでまずは原典に近いドキュメントを読んでみることにした。&lt;sup id=&#34;fnref:2&#34;&gt;&lt;a href=&#34;#fn:2&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;2&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;
&lt;p&gt;ここからは&lt;a href=&#34;https://cqrs.wordpress.com/wp-content/uploads/2010/11/cqrs_documents.pdf&#34; target=&#34;_blank&#34; &gt;CQRS Documents&lt;/a&gt;の内容をまとめていく。&lt;/p&gt;
&lt;h2 id=&#34;a-stereotypical-architecture-典型的なアーキテクチャ&#34;&gt;&amp;ldquo;A Stereotypical Architecture&amp;rdquo;: 典型的なアーキテクチャ&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;A Stereotypical Architecture&amp;quot;として、典型的なアーキテクチャが紹介されている。CQRS Documentsではこのアーキテクチャに対して段階的にCQRSを導入していく形で説明が進んでいく。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;a-stereotypical-architecture.webp&#34; alt=&#34;a-stereotypical-architecture.webp&#34;&gt;
CQRS Documents by Greg Young P2より引用&lt;/p&gt;
&lt;p&gt;このアーキテクチャではシステムはCRUDのみの機能を持ち、クライアントとは&lt;strong&gt;常にDTOを介して通信する。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;おそらくクライアントが&lt;code&gt;UpdateUserName&lt;/code&gt;のようなエンドポイントに更新後のユーザーネームだけを渡すのではなく&lt;code&gt;/user&lt;/code&gt;に更新後のDTOを丸ごと渡す、というようなことだと思われる。&lt;/p&gt;
&lt;p&gt;サーバー側では受け取ったDTOをドメインオブジェクトに詰め替えてバリデーションを行い、永続化する。&lt;/p&gt;
&lt;p&gt;このような設計ではアプリケーションサービスの責務はDTOとドメインオブジェクトの詰め替えに終始し、ドメイン層はバリデーションを主な責務として受け持つ。データの更新方法はクライアントに委ねられてしまうため、ドメイン知識の一部がクライアント側に漏れ出してしまう。&lt;/p&gt;
&lt;p&gt;このようなアーキテクチャでは簡潔性によってオンボーディングコストが低くなるメリットがある代わりに、次のような課題が存在する。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;スケーリング:&lt;/strong&gt; 一般的なシステムでは読み取り操作は書き込み操作よりも2桁以上多い。読み取り操作から見ると非正規化されたデータ構造が適しているが、書き込み操作から見ると正規化されたデータ構造が適している。これらを単一のDBで扱おうとすると垂直スケーリングが必要になるが、垂直スケーリングには非常に高額なコストがかかる。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DDD適用の困難さ:&lt;/strong&gt; この設計ではAPIがデータ指向のインターフェースを持つため、システム全体がCRUDの4つの動詞に縛られる。（データの更新方法がクライアントまたはユーザー側に漏れ出ておりドメイン知識をソフトウェアで表現することが難しいため）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ここまでの感想&#34;&gt;ここまでの感想&lt;/h3&gt;
&lt;p&gt;さすがにこういったアーキテクチャのシステムは見たことがないので極端な例では&amp;hellip;?とは思いつつ時代や場所によってはこういった設計のシステムも存在するのかもしれない。&lt;/p&gt;
&lt;h2 id=&#34;cqrsとは&#34;&gt;CQRSとは&lt;/h2&gt;
&lt;p&gt;CQRSはBertrand Meyerが提唱した&lt;a href=&#34;https://en.wikipedia.org/wiki/Command%E2%80%93query_separation&#34; target=&#34;_blank&#34; &gt;『Command and Query Separation Principle』&lt;/a&gt;にその起源を持つ。Wikipediaではこの原則を次のように説明している。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;It states that every method should either be a command that performs an action, or a query that returns data to the caller, but not both.&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Command%E2%80%93query_separation&#34; target=&#34;_blank&#34; &gt;Command–query separation - Wikipedia&lt;/a&gt; より引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;とあり、すべてのメソッドはCommandかQueryのいずれかであるべきであり、両方を兼ねるべきではないと説明されている。&lt;/p&gt;
&lt;p&gt;これに対し、Martin Fowlerは以下のようにPopのような操作はCommandでありQueryでもあり、必ずしも上記の原則を厳密に守らなくてもいいのではないか、ということを述べている。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Meyer likes to use command-query separation absolutely, but there are exceptions. Popping a stack is a good example of a modifier that modifies state. Meyer correctly says that you can avoid having this method, but it is a useful idiom. So I prefer to follow this principle when I can, but I&amp;rsquo;m prepared to break it to get my pop. (Fowler)&lt;/p&gt;
&lt;p&gt;CQRS Documents by Greg Young P17より引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ここまでの感想-1&#34;&gt;ここまでの感想&lt;/h3&gt;
&lt;p&gt;実際にWebサービスを開発していてもたとえばユーザー作成メソッドが作成したユーザーのIDを返すような処理は普通に書くし、自分もどちらかというと定義ほどは厳密に運用しなくても十分恩恵を受けられるのではないかという立場。&lt;/p&gt;
&lt;h2 id=&#34;a-stereotypical-architectureにcqrsを導入する&#34;&gt;&amp;ldquo;A Stereotypical Architecture&amp;quot;にCQRSを導入する&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;A Stereotypical Architecture&amp;quot;として最初に紹介されたアーキテクチャでは、ドメインモデルがCommandとQueryの両方に使用されていた。このアプリケーションにCQRSを適用するとQuery側とCommand側はそれぞれ次のようになる。&lt;/p&gt;
&lt;h3 id=&#34;query&#34;&gt;Query&lt;/h3&gt;
&lt;p&gt;Query処理側にはデータ取得のためのメソッドのみが含まれる。&lt;/p&gt;
&lt;p&gt;元のアーキテクチャではドメインモデルを生成し、それをDTOにマッピングしたうえでクライアントに返却していた。多くの場合でドメインモデルとDTOは異なるモデルであるため、以下のような課題があるがこれがCQRSの適用によって解決される。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;複数集約から1つのDTOを生成する場合、複数回DBにアクセスする必要がありパフォーマンスが低下する。また、集約の境界が曖昧になる。&lt;/li&gt;
&lt;li&gt;ドメイン層にQueryの責務が多く含まれている（e.g. repositoryのinterfaceにQuery系のメソッドが多く含まれ、ページングやソート情報が含まれている）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;After CQRS has been applied there is a natural boundary. Separate paths have been made explicit. It makes a lot of sense now to not use the domain to project DTOs. Instead it is possible to introduce a new way of projecting DTOs.&lt;/p&gt;
&lt;p&gt;CQRS Documents by Greg Young P20より引用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;とあるように、CQRSを適用することでCommandとQueryの処理経路が明確に分離される。この段階ではドメインモデルをDTOの生成に使用しない方が合理的である。&lt;/p&gt;
&lt;p&gt;その代わりに&amp;quot;Thin Read Layer&amp;quot;という方法でDTOを生成することができる。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;thin-read-layer.webp&#34; alt=&#34;thin-read-layer.webp&#34;&gt;
CQRS Documents by Greg Young P21より引用&lt;/p&gt;
&lt;p&gt;この層はDBから直接データを読み取り（ドメインモデルを迂回し）DTOを生成する。&lt;/p&gt;
&lt;p&gt;こうすることで、&lt;strong&gt;ドメイン層からQueryの責務を切り離すことができ、ドメイン層の純度を上げることができる。&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;command&#34;&gt;Command&lt;/h3&gt;
&lt;p&gt;CQRSを適用するとCommand側のアーキテクチャは以下のようになる。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;the-command-site.webp&#34; alt=&#34;the-command-site.webp&#34;&gt;
CQRS Documents by Greg Young P22より引用&lt;/p&gt;
&lt;p&gt;元のアーキテクチャでは書き込み系の処理をする際もDTOをクライアントから受け取っていたが、CQRS適用後はデータ中心ではなく振る舞い中心の契約を採用している点と読み取り処理が分離されている点が大きな違い。（元のアーキテクチャでは書き込み時にクライアントからDTOを渡していたが、ここではメッセージが渡されるようになっている）&lt;/p&gt;
&lt;p&gt;また、元のアーキテクチャでドメイン層に存在していた次のような課題が解決されている。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;リポジトリに大量の読み取りメソッドが存在する&lt;/li&gt;
&lt;li&gt;DTO構築のためにドメインオブジェクトの内部状態を公開するゲッターメソッドが存在する&lt;/li&gt;
&lt;li&gt;DTO構築のために複数の集約オブジェクトをそれぞれ読み込むことで、非効率なクエリが実行される&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;ドメインイベントイベントソーシング&#34;&gt;ドメインイベント、イベントソーシング&lt;/h3&gt;
&lt;p&gt;本文にはドメインイベント、イベントソーシングについても記載があり読んだがここでは割愛。&lt;/p&gt;
&lt;h3 id=&#34;ここまでの感想-2&#34;&gt;ここまでの感想&lt;/h3&gt;
&lt;p&gt;ドメイン層からQuery系の責務を切り離すことでメンテナビリティが向上する、というのが自分が（直近）CQRSに興味を持っていた一番の理由だったのでそうだよなーと思いながら読んだ。&lt;/p&gt;
&lt;p&gt;また（書いてあるとおりだが）読み取り単位を必ずしもドメインモデル単位にする必要がないためパフォーマンスの最適化が行いやすい点も大きなメリットだといえそう。&lt;/p&gt;
&lt;p&gt;結局CommandとQueryはまったく別の責務なことが多いので両者を分離することでメリットを得られるケースは多そう。&lt;/p&gt;
&lt;h2 id=&#34;作業習慣の違い&#34;&gt;作業習慣の違い&lt;/h2&gt;
&lt;p&gt;CQRS Documentsを読むまでは意識していなかったが、CQRSを採用することで&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ドメイン層&lt;/li&gt;
&lt;li&gt;リードモデル&lt;/li&gt;
&lt;li&gt;クライアント&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;の3つの要素に分解して作業を進めることができるため、プロジェクトに関わる開発者数をより効果的に増やすことができる。（サーバーとクライアントの作業分担をできるのはCQRSかどうかにかかわらないが、重要なのは1つのサーバーアプリケーションを2並列で安全に進めやすいという点だろう。）&lt;/p&gt;
&lt;p&gt;また、開発者には次のような観点の差異が存在する。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;技術的熟練度&lt;/li&gt;
&lt;li&gt;ビジネスドメインに関する知識&lt;/li&gt;
&lt;li&gt;コスト&lt;/li&gt;
&lt;li&gt;ソフトスキル&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ドメイン層の実装には4つすべての項目が秀でた人材が最適である一方、リードモデルの実装にはそれらの開発者要件は必ずしも当てはまるとは限らない。&lt;/p&gt;
&lt;h3 id=&#34;ここまでの感想-3&#34;&gt;ここまでの感想&lt;/h3&gt;
&lt;p&gt;開発効率の観点は持ってなかったが、たしかにCQRSを採用することで（1つのアプリケーションが2つのモジュールに分離されるので）コンフリクトせずに開発を進めやすそう。（モジュール設計はプロジェクトによるので厳密には2つのモジュールとは限らないが）&lt;/p&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;p&gt;事前のイメージ通り、CQRSを適用することで開発効率を高められそうなイメージが持てた。&lt;/p&gt;
&lt;p&gt;CQRS Documents内でも触れられていたが、結局CQRSにしろイベントソーシングにしろ一定のオーバーヘッドはあるので、システムやビジネスの課題や要件、今後の見通しを元に必要性を検討するのが（いつだって）重要そう。&lt;/p&gt;
&lt;p&gt;というのはありつつ、ドメイン層のメンテナビリティを高めるためにCQRSを採用するのはかなり有効な選択肢の1つだとも感じているので、ひとまず個人のプロジェクトで検証してみたいと思う。&lt;/p&gt;
&lt;div class=&#34;footnotes&#34; role=&#34;doc-endnotes&#34;&gt;
&lt;hr&gt;
&lt;ol&gt;
&lt;li id=&#34;fn:1&#34;&gt;
&lt;p&gt;もちろんアプリケーションの状況にもよるが&amp;hellip;。repositoryのRead系メソッドの返り値がドメインモデルと一致&lt;strong&gt;しない&lt;/strong&gt;ケースが多くなるような場合では特にCQRSのメリットが効果を発揮しやすいような気がしている。状況にかかわらずCQRSをやったほうがいいのかどうかはまだあまりわかっていない。ちなみにここでのCQRSは基本的には&lt;strong&gt;同一DB&lt;/strong&gt;でCのアプリケーションコードとQのアプリケーションコードが分離されている、くらいの方法をざっくり想定して書いている。（CとQでDBを分けるパターンは流石にtoo muchなケースが多そうなので）&amp;#160;&lt;a href=&#34;#fnref:1&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li id=&#34;fn:2&#34;&gt;
&lt;p&gt;厳密にこのドキュメントが原典であることを確認したわけではない。正確な情報をお持ちの方がいたら教えて下さい。&amp;#160;&lt;a href=&#34;#fnref:2&#34; class=&#34;footnote-backref&#34; role=&#34;doc-backlink&#34;&gt;&amp;#x21a9;&amp;#xfe0e;&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
</content>
    </item>
    
  </channel>
</rss>
