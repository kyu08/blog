<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>設計 on blog.kyu08.com</title>
    <link>https://blog.kyu08.com/tags/%E8%A8%AD%E8%A8%88/</link>
    <description>Recent content in 設計 on blog.kyu08.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>blog.kyu08.com</copyright>
    <lastBuildDate>Sat, 04 Oct 2025 08:21:10 +0000</lastBuildDate><atom:link href="https://blog.kyu08.com/tags/%E8%A8%AD%E8%A8%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>『Tidy First?』を読んだ</title>
      <link>https://blog.kyu08.com/posts/tidy-first/</link>
      <pubDate>Sat, 04 Oct 2025 08:21:10 +0000</pubDate>
      
      <guid>https://blog.kyu08.com/posts/tidy-first/</guid>
      <description>『Tidy First? 』を読んだ。 勉強になったところをまとめる。 「整頓」という概念 整頓はリファクタリングのサブセットだ。整頓は可愛くてふわふわした小さ</description>
      <content>&lt;p&gt;『&lt;a href=&#34;https://www.oreilly.co.jp/books/9784814400911/&#34; target=&#34;_blank&#34; &gt;Tidy First?&lt;/a&gt;
』を読んだ。&lt;/p&gt;
&lt;p&gt;勉強になったところをまとめる。&lt;/p&gt;
&lt;h2 id=&#34;整頓という概念&#34;&gt;「整頓」という概念&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;整頓はリファクタリングのサブセットだ。整頓は可愛くてふわふわした小さなリファクタリングなので、誰も嫌いになれないはずだ。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;リファクタリングほど大掛かりなものではなく、数十分でできるような小さな改善を本書では「整頓」と呼んでいる。&lt;/p&gt;
&lt;p&gt;具体的にはコードコメントを追加したり適切な位置に空行を配置したり適切な変数名に変更したりすることなどを指している。&lt;/p&gt;
&lt;p&gt;この「整頓」という概念を知ることができたのが本書を読んで得られた最大の収穫だった。今までそのような行為に名前をつけたことがなかったが名前をつけることで使い所や意義が明確になり意識的に実践できるようになりそう。&lt;/p&gt;
&lt;p&gt;なお本書では「整頓」と「振る舞いの変更」の順番やタイミング、粒度や意義について様々な角度から書かれているので気になる方はぜひ手にとってみてほしい。&lt;/p&gt;
&lt;h2 id=&#34;第11章-ステートメントを小分けにする&#34;&gt;第11章 ステートメントを小分けにする&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;大きなコードのチャンクを読んでいると、「ああ、ここは&lt;strong&gt;これ&lt;/strong&gt;をしていて、あそこで&lt;strong&gt;あれ&lt;/strong&gt;をしているのか」とわかる。そのあいだに空行を入れよう。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;長めの関数を読むとき、空行がまったくないことは少ないが空行の位置を改善できそうだと感じることがたまにある。&lt;/p&gt;
&lt;p&gt;処理の塊ごとに適切に改行されているだけでそこそこ可読性が上がる実感があるのでやってみようと思う。（空行の追加/削除のみのPRであればレビュワーの負担もかなり少ないはず）&lt;/p&gt;
&lt;h2 id=&#34;第13章-ひとかたまり&#34;&gt;第13章 ひとかたまり&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;細かく分割されているがゆえに、かえって理解を妨げているようなコードに出会うことはないだろうか。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;超巨大な関数はテストしづらく可読性も低いので避けたいが、逆にすべての処理を関数として切り出してしまうと毎回定義ジャンプしないと処理の内容がわからないのでかえって読みづらくなってしまう。&lt;/p&gt;
&lt;p&gt;テストが書きやすい程度に細かくかつ可読性が落ちない程度には大きく関数を切り出すのがよさそうで、いい塩梅を探るには複数のパターンを実際に書いてみて読みやすいかどうかを判断するのがよさそう。（実際に複数パターンを書いてみると意外とすぐに書けることが多いし、しかも実際に書いてみると事前の想定とは印象が違うことが多いように思う）&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;小さな部品に分けようとするのは、コードを少しずつ理解できるようにしたいからだ。だが、ときには、このプロセスが間違った方向に進むことがある。小さな部品のやりとりの仕方によっては、コードが&lt;strong&gt;理解しにくくなる&lt;/strong&gt;のだ。明確さを取り戻すには、まずはコードを1箇所に集めて、それから改めて、簡単に理解できる部品を抽出する。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1000行の関数でこれをやるとさすがに辛そうだが、100行前後くらいであればひとまず1つにまとめてから再構成するのはたしかに良さそう。&lt;/p&gt;
&lt;h2 id=&#34;第14章-説明コメント&#34;&gt;第14章 説明コメント&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;コードを読んでいて「なるほど、それで&lt;strong&gt;こう&lt;/strong&gt;なっているのか」と声が出ることがある。これは貴重な瞬間だ。記録しよう。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;コードリーディングの結果、必要なコメントが欠けていることに気づくことがある。&lt;/p&gt;
&lt;p&gt;そういった場面でこれまであまりPRを作ったりはしてこなかったが、説明コメントの追加も立派な整頓であり将来の読者（当然将来の自分を含む）の時間を節約することに繋がるのでやっていきたい。&lt;/p&gt;
&lt;p&gt;説明コメントの追加PRはレビュワーの負荷が少ない割にレビュイーとレビュワーのコード理解を深められる点で比較的コスパの良い取り組みな気がした。（正確な説明コメントを書くための調査が大変、とかはあるかもだが）&lt;/p&gt;
&lt;h2 id=&#34;第19章-リズム&#34;&gt;第19章 リズム&lt;/h2&gt;
&lt;p&gt;1つの整頓にかける時間はここでは1時間くらいまでが許容範囲とされており、それを大幅に超過するようであれば変更の単位が大きすぎる兆候らしい。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;こんな話を聞いたことはないだろうか。ある大学がたくさんの建物を造った。計画者は、それを結ぶ歩道をどこに造るか考えていた。だが、そこで経験にもとづいて注意深く推測するのではなく、建物のあいだのエリアに芝生を植えたのだ。
数か月後、学生の歩いた跡によって芝生に道ができた。計画者は芝生がなくなったところを舗装した。&lt;/p&gt;
&lt;p&gt;コードにおいて、振る舞いの変更は一部に集中する傾向にある。パレートの法則にあるように、80%の変更は20%のファイルで起こる。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;（計画者天才すぎワロタ&amp;hellip;）&lt;/p&gt;
&lt;p&gt;変更の前に整頓することを続けていくと頻繁に変更される20%のコードがどんどん綺麗になっていく、ということを言っているのだと解釈した。&lt;/p&gt;
&lt;p&gt;そうした取り組みを続けていくとコードの大部分は手直ししてないにもかかわらず整頓していないコードに出会うことは稀になる。逆に言うと仮にコードの50%を頑張って綺麗にしたところで、その50%に変更がまったく入らないのであれば投資対効果が高いとはいえないかもしれない。（当然、コード全体が複雑に絡み合っていて一部だけ再設計することが難しい場合や全体的に変更しないと一貫性がなくなる場合などはその限りではないと思う）&lt;/p&gt;
&lt;p&gt;なのでコードを修正する際は単純にある時点のコードベースだけを見てコード品質に改善点が見つかったというだけの理由で修正する、というよりは修正すべき合理的な理由（e.g. 内部品質が課題で問題が起きている、よく変更が入る箇所が変更しづらくなっているなど）がある箇所から対応していくのがよさそう。&lt;/p&gt;
&lt;h2 id=&#34;第21章-先に整頓あとに整頓改めて整頓整頓しない&#34;&gt;第21章 先に整頓、あとに整頓、改めて整頓、整頓しない&lt;/h2&gt;
&lt;p&gt;整頓を変更の前にやるか、あとにやるか、将来時間がとれたときにやるか、あるいはまったくやらないかについて論じた章。&lt;/p&gt;
&lt;p&gt;章のまとめにもあるように結局はビジネスにとって合理的なタイミングでやるのがよい、ということなのだと思った。（言葉にするとそれはそうという感じではあるが）&lt;/p&gt;
&lt;p&gt;「改めて整頓する」と「あとに整頓する」の区別はあまり考えたことがなかったが、整頓が完了するまでの必要工数が
大きいケース以外は「あとに整頓する」に寄せるのが良さそうに感じた。&lt;/p&gt;
&lt;h2 id=&#34;第25章-明日の1ドルより今日の1ドル&#34;&gt;第25章 明日の1ドルより今日の1ドル&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;お金を生む振る舞いの変更を今すぐ実装して、あとから整頓できるなら、すぐにお金が手に入り、あとでお金を使うことになる(前述のとおり、ときには先に整頓してから振る舞いを変更するほうが整頓せずに変更するよりも安価なこともある。そんな場合は常に先に整頓する)。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;ビジネス的なメリットがあるならば整頓を後回しにすることが合理的になるのは十分にありえる。(e.g. 12/1までにリリースできれば大企業A社の受注に繋がるが、それを超過してしまうと競合他社と契約されてしまい、A社と契約できるチャンスが消滅してしまう)&lt;/p&gt;
&lt;p&gt;逆に、先に整頓したほうが変更が楽になるならそうする。コードベースへの理解、ビジネスへの関心と理解（デッドラインは最終的なものなのか、調整可能なのか）、一定の設計スキルなどがあるとこの判断の練度を上げることに繋がりそう。&lt;/p&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;第26章-オプション&#34;&gt;第26章 オプション&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;「次にどのような振る舞いを実装できるか」は、実装する前から、それ自体に価値がある。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;これはあまり考えたことがなかった。「プログラムの変更容易性は将来の実装工数を削減するために重要である」というアイディアと本質的には近いことを言ってそうだが、「価値」という切り口で捉え直すとたしかに変更容易性は価値と等価ともいえそう。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;（これが最重要なのだが）価値予測の不確実性が&lt;strong&gt;高い&lt;/strong&gt;ほど、オプションの価値は&lt;strong&gt;高い&lt;/strong&gt;（今すぐ実装するのと比べて）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;価値予測の不確実性と変更容易性の価値についてもあまり考えたことがなかったが納得感があった。たとえばよくあるSaaSモデルのプロダクトであれば探索しながら市場の反応を見たり変化に対応したりすることが必要で、そのためには変更容易性が必要なのでその価値がより高まる、ということだと理解した。&lt;/p&gt;
&lt;h2 id=&#34;第32章-凝集&#34;&gt;第32章 凝集&lt;/h2&gt;
&lt;p&gt;凝集性が低いモジュールの改善方法についての章だが、どちらかというと章の後半に書かれていた下記の記述が参考になった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;次の人のために少しだけコードを整頓しておこう。全員がこのボーイスカウトルール(「来たときよりも美しく」)に従えば、そのうちにより扱いやすいコードになっていくだろう。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;これまではボーイスカウトルールというと「触ったコードの負債をできるだけ&lt;strong&gt;リファクタリングして綺麗にすべし&lt;/strong&gt;」のような考え方だと認識していた（これ自体は間違いではないと思う）。&lt;/p&gt;
&lt;p&gt;本格的なリファクタリングまではいかなくとも、本書で「整頓」として紹介されている「コードコメントの追加」や「空行の調整」なども十分ボーイスカウト的な行為なのだなと考え直して少しハードルが下がる感覚を得た。&lt;/p&gt;
&lt;h2 id=&#34;第33章-結論&#34;&gt;第33章 結論&lt;/h2&gt;
&lt;p&gt;本書のタイトルにもなっている、どんなときに先に整頓すべきかについてのまとめの章。&lt;/p&gt;
&lt;p&gt;以下の4つの観点で整理して決断するとよい、と書かれている。次に判断に迷った際には参考にしてみたい。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;コスト&lt;/li&gt;
&lt;li&gt;収益&lt;/li&gt;
&lt;li&gt;結合&lt;/li&gt;
&lt;li&gt;凝集&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;!-- raw HTML omitted --&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;164ページと全体がコンパクトにまとまっているのと、簡潔に書かれている（かつ、翻訳もとても読みやすい）ので短時間で読みやすかった。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「整頓」&lt;/strong&gt; という概念を知れたのが最大の収穫だった。今後は意識的に実践していきたいと思う。&lt;/p&gt;
&lt;p&gt;次回作の構想もあるようなので楽しみ。&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>『ちょうぜつソフトウェア設計入門 PHPで理解するオブジェクト指向の活用』を読んだ</title>
      <link>https://blog.kyu08.com/posts/chozetsu-bon/</link>
      <pubDate>Sat, 15 Jul 2023 15:00:00 +0000</pubDate>
      
      <guid>https://blog.kyu08.com/posts/chozetsu-bon/</guid>
      <description>田中ひさてるさんの『ちょうぜつソフトウェア設計入門――PHPで理解するオブジェクト指向の活用』が話題になっていたので読んでみた。 全体を通して</description>
      <content>&lt;p&gt;田中ひさてるさんの『ちょうぜつソフトウェア設計入門――PHPで理解するオブジェクト指向の活用』が話題になっていたので読んでみた。&lt;/p&gt;
&lt;p&gt;全体を通して平易な日本語で書かれていたのとコード例が豊富だったので理解しやすくてよかった。&lt;/p&gt;
&lt;p&gt;以下学びを簡単にまとめていく。&lt;/p&gt;
&lt;h2 id=&#34;第2章-パッケージ原則&#34;&gt;第2章 パッケージ原則&lt;/h2&gt;
&lt;p&gt;より変更に強いパッケージ設計にするために注意すべき点として&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パッケージの凝集性を高める&lt;/li&gt;
&lt;li&gt;より安定度が高い(=抽象度が高い)パッケージに依存する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などがある。&lt;/p&gt;
&lt;p&gt;また、&lt;strong&gt;凝集性の低さを表すシグナル&lt;/strong&gt;として&lt;strong&gt;そのパッケージが変更される理由が複数あること&lt;/strong&gt;・&lt;strong&gt;1つの変更の際に変更対象となるパッケージが複数あること&lt;/strong&gt;(それぞれ同じ?)が挙げられる。&lt;/p&gt;
&lt;p&gt;「抽象」については以下のように説明されていた。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;抽象クラスやインターフェイスなど実装詳細を自身から排除したもの&lt;/li&gt;
&lt;li&gt;上記のような詳細を持たないものだけに依存するロジック&lt;/li&gt;
&lt;li&gt;固有の業務にも特定技術にも関係しない時刻や配列などの汎用概念とその操作&lt;/li&gt;
&lt;li&gt;プログラミング言語そのものや言語標準ライブラリと同等レベルの業界標準&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第3章-オブジェクト指向&#34;&gt;第3章 オブジェクト指向&lt;/h2&gt;
&lt;h3 id=&#34;いい抽象を見つけるには&#34;&gt;いい抽象を見つけるには&lt;/h3&gt;
&lt;p&gt;具体的な例を分析してそれらから抽象を見つけることで期待値の高い抽象を発見できる。&lt;/p&gt;
&lt;p&gt;逆に先に&lt;strong&gt;ひとりよがりの哲学をこねくり回して現実をかえりみない抽象化を先行させた&lt;/strong&gt;場合は、&lt;strong&gt;役に立たない概念に縛られる無駄が起きやすくなる。&lt;/strong&gt;（ペットショップのシステムなのに「Catには野良猫もいるかもしれない。必ずしもPetではないかも&amp;hellip;…」みたいなことを考えてしまうのは明らかに無駄）（抽象化においてもYAGNIが重要っぽい）&lt;/p&gt;
&lt;p&gt;無限の可能性に向かって発散してしまわず、いかに可能性を削ぎ落として最小サイズで実際に起こりうるバリエーションをカバーできるかが汎化のポイント。&lt;/p&gt;
&lt;p&gt;そういう意味でもドメインやビジネスの状況を理解しておくことはプロダクトの将来を考慮しながら設計するために必要なんだろうなと思った。&lt;/p&gt;
&lt;h3 id=&#34;多態性がなくても役立つ&#34;&gt;「多」態性がなくても役立つ&lt;/h3&gt;
&lt;p&gt;抽象と具象は必ずしも1対多の関係である必要はない。&lt;/p&gt;
&lt;p&gt;具象と抽象に分けておくことで先に大枠を安定させることができるため、設計の見通しがつきやすくなる。&lt;/p&gt;
&lt;p&gt;また、具象の数が複数になったときに対応しやすいというメリットもある。&lt;/p&gt;
&lt;p&gt;これまで「抽象と具象が1対1対応なケースはわざわざDIする必要はないのでは」と思っていたが上記のメリットがあるので積極的にDIしていこうと思った。&lt;/p&gt;
&lt;h2 id=&#34;第5章-オブジェクト指向原則-solid&#34;&gt;第5章 オブジェクト指向原則 SOLID&lt;/h2&gt;
&lt;h3 id=&#34;5-2-単一責任原則single-responsibility-principlesrp&#34;&gt;5-2 単一責任原則(Single Responsibility Principle(SRP))&lt;/h3&gt;
&lt;p&gt;クラスと責務は1対1対応すべき、という指針。&lt;/p&gt;
&lt;h4 id=&#34;単一の責務のみつけかた&#34;&gt;単一の責務のみつけかた&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;クラスの利用者がどんなときに別のクラスや新しいバージョンに交換したいと思うかを想像する。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;実際に起こりそうな交換要求への想像が責務(= クラスのカバー範囲)を見極めるヒントになる。&lt;/p&gt;
&lt;p&gt;たとえば記事クラスが存在し記事の入稿および購読というユースケースがある例では以下のように考えることができる。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ニュース記事を書く人の事情が変わったけれど、購読ユーザーには従来どおりのサービスを提供したい。逆に、入稿はそのまま、購読ユーザーへのサービスを拡張したい。そんなニーズが起きるのは容易に想像できます。入稿と購読のそれぞれを互いに影響を与えない独立したクラスとしておき、いつでも気兼ねなく別の実装に交換できる単位としておく方が、後で便利に決まっています。なので、ニュース記事管理の場合は、「入稿」と「購読」が、それぞれひとつの責務になります。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-3-開放閉鎖原則open-close-principle&#34;&gt;5-3 開放閉鎖原則(Open Close Principle)&lt;/h3&gt;
&lt;p&gt;拡張に対してオープン、変更にたいしてクローズドであるべき、という指針。&lt;/p&gt;
&lt;p&gt;これは書籍内で紹介されていたコード例がわかりやすかった。&lt;/p&gt;
&lt;p&gt;あとはどこが変化する仕様なのかを考えるために一度要件を抽象化してみる方法が紹介されていた。こちらもコード例が示されていたのでイメージが湧きやすかった。&lt;/p&gt;
&lt;h2 id=&#34;第7章-依存性注入&#34;&gt;第7章 依存性注入&lt;/h2&gt;
&lt;p&gt;オブジェクトが使う機能の実体を得る際その解決を自力で行わず、常に外部から与えるようにすべき、という設計方針。&lt;/p&gt;
&lt;p&gt;依存性注入を行うメリットの1つは生成の責務と使用の責務を分けられる点がある。&lt;/p&gt;
&lt;p&gt;また、テスト容易性とDIについては以下のような記述があった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;単体テストしやすいクラスであることと、DI可能なクラスであるということには、正の相関があります。DIを単に「単体テストのためにやること」といった目的観で考えるのは視野狭窄ではあるのですが、単体テストがアーキテクチャへの気づきの手段として、とても有用なのは間違いありません。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;テストが書きずらかったら設計を疑ってみるのも1つの手かもしれない。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;よく聞くSOLID原則もやっとちゃんと理解できたし依存性注入に対する理解も深まったので今後に活かしていきたい。&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>デザインパターンをひととおり眺めた感想</title>
      <link>https://blog.kyu08.com/posts/learn-design-pattern/</link>
      <pubDate>Wed, 01 Feb 2023 16:15:48 +0000</pubDate>
      
      <guid>https://blog.kyu08.com/posts/learn-design-pattern/</guid>
      <description>ずっと気になってはいたが2つ~3つくらいしか知らなかったデザインパターンをやっと勉強する気になったのでこのサイトを一通り眺めてみた。 https://refactoring.guru/ja/design-patterns こちら</description>
      <content>&lt;p&gt;ずっと気になってはいたが2つ~3つくらいしか知らなかったデザインパターンをやっと勉強する気になったのでこのサイトを一通り眺めてみた。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://refactoring.guru/ja/design-patterns&#34; target=&#34;_blank&#34; &gt;https://refactoring.guru/ja/design-patterns&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;こちらのサイトは平易な文章とわかりやすい例で説明がされていて、各言語でのサンプルコードも載せてくれていたのでかなりサクサクと理解できてとてもよかった。(各パターンをC#, C++, Go, Java, php, Python, Ruby, Rust, Swift, TypeScriptで実装した例が紹介されていた)(すごい)&lt;/p&gt;
&lt;h2 id=&#34;自分のデザインパターンとの向き合い方について&#34;&gt;自分のデザインパターンとの向き合い方について&lt;/h2&gt;
&lt;p&gt;周りのエンジニアにデザインパターンについて聞くと、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;すべてのパターンが今も有用かと言われるとそうでもないかも&lt;/li&gt;
&lt;li&gt;よくある設計パターンの共通言語として知っておくとコミュニケーションの効率があがってよい&lt;/li&gt;
&lt;li&gt;暗記までする必要はなくて設計のときの参考程度にするとよさそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;みたいなことを言っているのをよく聞くのですべてを自分のものにするというよりは軽く雰囲気を理解するくらいのテンションでサイトを眺めてみた。&lt;/p&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;p&gt;一通り眺めてみて、以下のようなことが重要なんだろうなと感じた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interfaceをうまく使って抽象に依存する&lt;/li&gt;
&lt;li&gt;データと振る舞いを分離する&lt;/li&gt;
&lt;li&gt;依存の方向に気を付ける&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;いろんなところで言われていることだが、やはり責務の分離や単一責任の法則を意識することで変更しやすいコードにしていくことがよりよい設計に繋がることを再確認できた。&lt;/p&gt;
&lt;p&gt;いいコードを書けるようになるにはこれらのことを意識しながら実際にコードを書いて実践していくことが重要だと思うのでたくさん試行錯誤していい感じのコード書き力を身につけていきたい。(とても経験豊富な先輩エンジニアも結局自分でサービスを運用して設計の失敗の痛みを感じるのが一番成長できる、というようなことを言っていた)&lt;/p&gt;
&lt;p&gt;設計関連だと &lt;a href=&#34;https://www.amazon.co.jp/dp/4297127830&#34; target=&#34;_blank&#34; &gt;良いコード/悪いコードで学ぶ設計入門 ―保守しやすい 成長し続けるコードの書き方&lt;/a&gt;
 とか &lt;a href=&#34;https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656&#34; target=&#34;_blank&#34; &gt;Clean Architecture&lt;/a&gt;
 とかも気になってるので読みたい。&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
