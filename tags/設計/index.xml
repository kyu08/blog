<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>設計 on blog.kyu08.com</title>
    <link>https://blog.kyu08.com/tags/%E8%A8%AD%E8%A8%88/</link>
    <description>Recent content in 設計 on blog.kyu08.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <copyright>blog.kyu08.com</copyright>
    <lastBuildDate>Sun, 16 Jul 2023 00:00:00 +0900</lastBuildDate><atom:link href="https://blog.kyu08.com/tags/%E8%A8%AD%E8%A8%88/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ちょうぜつ本を読んだ</title>
      <link>https://blog.kyu08.com/posts/chozetsu-bon/</link>
      <pubDate>Sun, 16 Jul 2023 00:00:00 +0900</pubDate>
      
      <guid>https://blog.kyu08.com/posts/chozetsu-bon/</guid>
      <description>田中ひさてるさんの『ちょうぜつソフトウェア設計入門――PHPで理解するオブジェクト指向の活用』が話題になっていたので読んでみた。 全体を通して</description>
      <content>&lt;p&gt;田中ひさてるさんの『ちょうぜつソフトウェア設計入門――PHPで理解するオブジェクト指向の活用』が話題になっていたので読んでみた。&lt;/p&gt;
&lt;p&gt;全体を通して平易な日本語で書かれていたのとコード例が豊富だったので理解しやすくてよかった。&lt;/p&gt;
&lt;p&gt;以下学びを簡単にまとめていく。&lt;/p&gt;
&lt;h2 id=&#34;第2章-パッケージ原則&#34;&gt;第2章 パッケージ原則&lt;/h2&gt;
&lt;p&gt;より変更に強いパッケージ設計にするために注意すべき点として&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;パッケージの凝集性を高める&lt;/li&gt;
&lt;li&gt;より安定度が高い(=抽象度が高い)パッケージに依存する&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;などがある。&lt;/p&gt;
&lt;p&gt;また、&lt;strong&gt;凝集性の低さを表すシグナル&lt;/strong&gt;として&lt;strong&gt;そのパッケージが変更される理由が複数あること&lt;/strong&gt;・&lt;strong&gt;1つの変更の際に変更対象となるパッケージが複数あること&lt;/strong&gt;(それぞれ同じ?)が挙げられる。&lt;/p&gt;
&lt;p&gt;「抽象」については以下のように説明されていた。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;抽象クラスやインターフェイスなど実装詳細を自身から排除したもの&lt;/li&gt;
&lt;li&gt;上記のような詳細を持たないものだけに依存するロジック&lt;/li&gt;
&lt;li&gt;固有の業務にも特定技術にも関係しない時刻や配列などの汎用概念とその操作&lt;/li&gt;
&lt;li&gt;プログラミング言語そのものや言語標準ライブラリと同等レベルの業界標準&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;第3章-オブジェクト指向&#34;&gt;第3章 オブジェクト指向&lt;/h2&gt;
&lt;h3 id=&#34;いい抽象を見つけるには&#34;&gt;いい抽象を見つけるには&lt;/h3&gt;
&lt;p&gt;具体的な例を分析してそれらから抽象を見つけることで期待値の高い抽象を発見することができる。&lt;/p&gt;
&lt;p&gt;逆に先に&lt;strong&gt;ひとりよがりの哲学をこねくり回して現実をかえりみない抽象化を先行させた&lt;/strong&gt;場合は、&lt;strong&gt;役に立たない概念に縛られる無駄が起きやすくなる。&lt;/strong&gt;（ペットショップのシステムなのに「Cat には野良猫もいるかもしれない。必ずしも Pet ではないかも&amp;hellip;…」みたいなことを考えてしまうのは明らかに無駄）（抽象化においてもYAGNIが重要っぽい）&lt;/p&gt;
&lt;p&gt;無限の可能性に向かって発散してしまわず、いかに可能性を削ぎ落として最小サイズで実際に起こりうるバリエーションをカバーできるかが汎化のポイント。&lt;/p&gt;
&lt;p&gt;そういう意味でもドメインやビジネスの状況を理解しておくことはプロダクトの将来を考慮しながら設計するために必要なんだろうなと思った。&lt;/p&gt;
&lt;h3 id=&#34;多態性がなくても役立つ&#34;&gt;「多」態性がなくても役立つ&lt;/h3&gt;
&lt;p&gt;抽象と具象は必ずしも1対多の関係である必要はない。&lt;/p&gt;
&lt;p&gt;具象と抽象に分けておくことで先に大枠を安定させることができるため、設計の見通しがつきやすくなる。&lt;/p&gt;
&lt;p&gt;また、具象の数が複数になったときに対応しやすいというメリットもある。&lt;/p&gt;
&lt;p&gt;これまで「抽象と具象が1対1対応なケースはわざわざDIする必要はないのでは」と思っていたが上記のメリットがあるので積極的にDIしていこうと思った。&lt;/p&gt;
&lt;h2 id=&#34;第5章-オブジェクト指向原則-solid&#34;&gt;第5章 オブジェクト指向原則 SOLID&lt;/h2&gt;
&lt;h3 id=&#34;5-2-単一責任原則single-responsibility-principlesrp&#34;&gt;5-2 単一責任原則(Single Responsibility Principle(SRP))&lt;/h3&gt;
&lt;p&gt;クラスと責務は1対1対応すべき、という指針。&lt;/p&gt;
&lt;h4 id=&#34;単一の責務のみつけかた&#34;&gt;単一の責務のみつけかた&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;クラスの利用者がどんなときに別のクラスや新しいバージョンに交換したいと思うかを想像する。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;実際に起こりそうな交換要求への想像が責務(= クラスのカバー範囲)を見極めるヒントになる。&lt;/p&gt;
&lt;p&gt;たとえば記事クラスが存在し記事の入稿および購読というユースケースがある例では以下のように考えることができる。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ニュース記事を書く人の事情が変わったけれど、購読ユーザーには従来どおりのサービスを提供したい。逆に、入稿はそのまま、購読ユーザーへのサービスを拡張したい。そんなニーズが起きるのは容易に想像できます。入稿と購読のそれぞれを互いに影響を与えない独立したクラスとしておき、いつでも気兼ねなく別の実装に交換できる単位としておく方が、後で便利に決まっています。なので、ニュース記事管理の場合は、「入稿」と「購読」が、それぞれひとつの責務になります。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;5-3-開放閉鎖原則open-close-principle&#34;&gt;5-3 開放閉鎖原則(Open Close Principle)&lt;/h3&gt;
&lt;p&gt;拡張に対してオープン、変更にたいしてクローズドであるべき、という指針。&lt;/p&gt;
&lt;p&gt;これは書籍内で紹介されていたコード例がわかりやすかった。&lt;/p&gt;
&lt;p&gt;あとはどこが変化する仕様なのかを考えるために一度要件を抽象化してみる方法が紹介されていた。こちらもコード例が示されていたのでイメージが湧きやすかった。&lt;/p&gt;
&lt;h2 id=&#34;第7章-依存性注入&#34;&gt;第7章 依存性注入&lt;/h2&gt;
&lt;p&gt;オブジェクトが使う機能の実体を得る際その解決を自力で行わず、常に外部から与えるようにすべき、という設計方針。&lt;/p&gt;
&lt;p&gt;依存性注入を行うメリットの1つは生成の責務と使用の責務を分けられる点がある。&lt;/p&gt;
&lt;p&gt;また、テスト容易性とDIについては以下のような記述があった。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;単体テストしやすいクラスであることと、DI可能なクラスであるということには、正の相関があります。DIを単に「単体テストのためにやること」といった目的観で考えるのは視野狭窄ではあるのですが、単体テストがアーキテクチャへの気づきの手段として、とても有用なのは間違いありません。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;テストが書きずらかったら設計を疑ってみるのも一つの手かもしれない。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;よく聞くSOLID原則もやっとちゃんと理解できたし依存性注入に対する理解も深まったので今後に活かしていきたい。&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>デザインパターンをひととおり眺めた感想</title>
      <link>https://blog.kyu08.com/posts/learn-design-pattern/</link>
      <pubDate>Thu, 02 Feb 2023 01:15:48 +0900</pubDate>
      
      <guid>https://blog.kyu08.com/posts/learn-design-pattern/</guid>
      <description>ずっと気になってはいたが2つ~3つくらいしか知らなかったデザインパターンをやっと勉強する気になったのでこのサイトを一通り眺めてみた。 https://refactoring.guru/ja/design-patterns こちら</description>
      <content>&lt;p&gt;ずっと気になってはいたが2つ~3つくらいしか知らなかったデザインパターンをやっと勉強する気になったのでこのサイトを一通り眺めてみた。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://refactoring.guru/ja/design-patterns&#34; target=&#34;_blank&#34; &gt;https://refactoring.guru/ja/design-patterns&lt;/a&gt;
&lt;/p&gt;
&lt;p&gt;こちらのサイトは平易な文章とわかりやすい例で説明がされていて、各言語でのサンプルコードも載せてくれていたのでかなりサクサクと理解できてとてもよかった。(各パターンをC#, C++, Go, Java, php, Python, Ruby, Rust, Swift, TypeScriptで実装した例が紹介されていた)(すごい)&lt;/p&gt;
&lt;h2 id=&#34;自分のデザインパターンとの向き合い方について&#34;&gt;自分のデザインパターンとの向き合い方について&lt;/h2&gt;
&lt;p&gt;周りのエンジニアにデザインパターンについて聞くと、&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;すべてのパターンが今も有用かと言われるとそうでもないかも&lt;/li&gt;
&lt;li&gt;よくある設計パターンの共通言語として知っておくとコミュニケーションの効率があがってよい&lt;/li&gt;
&lt;li&gt;暗記までする必要はなくて設計のときの参考程度にするとよさそう&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;みたいなことを言っているのをよく聞くのですべてを自分のものにするというよりは軽く雰囲気を理解するくらいのテンションでサイトを眺めてみた。&lt;/p&gt;
&lt;h2 id=&#34;感想&#34;&gt;感想&lt;/h2&gt;
&lt;p&gt;一通り眺めてみて、以下のようなことが重要なんだろうなと感じた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;interfaceをうまく使って抽象に依存する&lt;/li&gt;
&lt;li&gt;データと振る舞いを分離する&lt;/li&gt;
&lt;li&gt;依存の方向に気を付ける&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;いろんなところで言われていることだが、やはり責務の分離や単一責任の法則を意識することで変更しやすいコードにしていくことがよりよい設計に繋がることを再確認できた。&lt;/p&gt;
&lt;p&gt;いいコードを書けるようになるにはこれらのことを意識しながら実際にコードを書いて実践していくことが重要だと思うのでたくさん試行錯誤していい感じのコード書き力を身につけていきたい。(とても経験豊富な先輩エンジニアも結局自分でサービスを運用して設計の失敗の痛みを感じるのが一番成長できる、というようなことを言っていた)&lt;/p&gt;
&lt;p&gt;設計関連だと &lt;a href=&#34;https://www.amazon.co.jp/dp/4297127830&#34; target=&#34;_blank&#34; &gt;良いコード/悪いコードで学ぶ設計入門 ―保守しやすい 成長し続けるコードの書き方&lt;/a&gt;
 とか &lt;a href=&#34;https://www.amazon.co.jp/Clean-Architecture-%E9%81%94%E4%BA%BA%E3%81%AB%E5%AD%A6%E3%81%B6%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%81%AE%E6%A7%8B%E9%80%A0%E3%81%A8%E8%A8%AD%E8%A8%88-Robert-C-Martin/dp/4048930656&#34; target=&#34;_blank&#34; &gt;Clean Architecture&lt;/a&gt;
 とかも気になってるので読みたい。&lt;/p&gt;
</content>
    </item>
    
  </channel>
</rss>
