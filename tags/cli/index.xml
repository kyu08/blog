<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>cli on blog.kyu08.com</title><link>https://blog.kyu08.com/tags/cli/</link><description>Recent content in cli on blog.kyu08.com</description><generator>Hugo -- gohugo.io</generator><language>ja</language><copyright>kyu08.com</copyright><lastBuildDate>Fri, 31 Mar 2023 01:15:48 +0900</lastBuildDate><atom:link href="https://blog.kyu08.com/tags/cli/index.xml" rel="self" type="application/rss+xml"/><item><title>Makefileに定義されたtargetをfzfで選択して実行するCLIツールをRustでつくった</title><link>https://blog.kyu08.com/posts/fzf-make/</link><pubDate>Fri, 31 Mar 2023 01:15:48 +0900</pubDate><guid>https://blog.kyu08.com/posts/fzf-make/</guid><description>Makefileに定義されたtargetをfzfで選択して実行するCLIツールをRustでつくった。 https://github.com/kyu08/fzf-make こんな感じで動く。 fzf-makeがや</description><content>&lt;p>Makefileに定義されたtargetをfzfで選択して実行するCLIツールをRustでつくった。&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/fzf-make">https://github.com/kyu08/fzf-make&lt;/a>&lt;/p>
&lt;p>こんな感じで動く。&lt;/p>
&lt;p>&lt;img src="fzf-make-demo.gif" alt="fzf-make-demo">&lt;/p>
&lt;h2 id="fzf-makeがやっていること">fzf-makeがやっていること&lt;/h2>
&lt;ol>
&lt;li>&lt;code>Makefile&lt;/code>からtargetを正規表現で抜き出す&lt;/li>
&lt;li>&lt;code>skim&lt;/code>(※)に実行オプションとtargetたちを渡す&lt;/li>
&lt;li>&lt;code>skim&lt;/code>がプレビューウィンドウ付きのfuzzy-finderを表示&lt;/li>
&lt;li>&lt;code>skim&lt;/code>から選択されたtargetが返ってくるので&lt;code>make ${target}&lt;/code>を実行&lt;/li>
&lt;/ol>
&lt;p>基本的な動作はすべて&lt;code>skim&lt;/code>任せになっていてRust側でやっているのは&lt;code>skim&lt;/code>とのやりとりくらいになっている。&lt;/p>
&lt;p>※&lt;a href="https://github.com/lotabout/skim">lotabout/skim&lt;/a>&amp;hellip;Rust製のfuzzy-finder。Rustのライブラリとして利用することもできる。&lt;/p>
&lt;p>(makeの文法が思ったより多彩っぽかったので自分が必要とするごく簡単なユースケース以外をカバーするのは&lt;a href="https://twitter.com/kyu08_/status/1639986936407531525">早々に諦めた。&lt;/a>(makeで1冊本が書けるぐらいだしそれはそうという感じではある))&lt;/p>
&lt;p>brewコマンドでインストールできるので気になる方はぜひ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-sh" data-lang="sh">&lt;span style="display:flex;">&lt;span>brew tap kyu08/tap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install kyu08/tap/fzf-make
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>ソースも公開しているので、「こう書くといいよ」とかバグとかありましたらぜひissueやPRで教えてください。&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/fzf-make">https://github.com/kyu08/fzf-make&lt;/a>&lt;/p>
&lt;h2 id="実装">実装&lt;/h2>
&lt;p>上述の通り処理の大部分はskim任せになっている。(書いたコードはテストを含めても200行程度)&lt;/p>
&lt;p>ただskimをライブラリとして利用する実装サンプルがあまりなかったのがちょっと大変だった。特にプレビューウィンドウの表示にfzfの候補文字列を変数としたシェルコマンドの形で渡すことができることに気づくまでに時間がかかった&lt;/p>
&lt;p>↓の&lt;code>{}&lt;/code>にtarget名が入るイメージ。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-rust" data-lang="rust">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">let&lt;/span> preview_command &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">r&lt;/span>&lt;span style="color:#e6db74">&amp;#34;line=$(bat Makefile | grep -nE &amp;#39;^{}\s*:&amp;#39; | sed -e &amp;#39;s/:.*//g&amp;#39;); bat --style=numbers --color=always --line-range $line: --highlight-line $line Makefile&amp;#34;&lt;/span>;
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;a href="https://github.com/kyu08/fzf-make/blob/3a627d0a1aa75b1bf1ff87f3443f63393afbcf10/src/misc.rs#L18">https://github.com/kyu08/fzf-make/blob/3a627d0a1aa75b1bf1ff87f3443f63393afbcf10/src/misc.rs#L18&lt;/a>&lt;/p>
&lt;p>あとはgoでいつもやっている感じでテーブル駆動テストっぽくテストを書いてみた。可読性も保守性も高いので割と気に入っている。&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/fzf-make/blob/3a627d0a1aa75b1bf1ff87f3443f63393afbcf10/src/misc.rs#L145">https://github.com/kyu08/fzf-make/blob/3a627d0a1aa75b1bf1ff87f3443f63393afbcf10/src/misc.rs#L145&lt;/a>&lt;/p>
&lt;h2 id="動機">動機&lt;/h2>
&lt;ul>
&lt;li>Rustが書きたかった。(以上)&lt;/li>
&lt;/ul>
&lt;p>最近Rustのやっていきが高まっており、&lt;a href="https://doc.rust-jp.rs/book-ja/">The Rust Programming Language&lt;/a> を1周したので何か作ってみるぞーという機運とMakefileのターゲットをfuzzy-finderで絞り込めたら便利そうだなーという気持ちが重なったのでRustでfzf-makeを作ってみた。 (あとはskimの存在を知っていたのも大きい。)&lt;/p>
&lt;p>自分が欲しいCLIツールを手に入れつつRustの経験が積めたのでよかった。&lt;/p>
&lt;p>ちなみにRustに入門した直接的(?)なきっかけとしてはこのスライドを目にして、「Elmっぽい！楽しそう！」と思ったのが発端だった。Rustに興味を持っている人はぜひ読んでみて欲しい。&lt;/p>
&lt;p>&lt;a href="https://speakerdeck.com/estie/man-wochi-siteshi-merurust">満を持して始める Rust&lt;/a>&lt;/p>
&lt;h2 id="rustを触ってみて感じたこと">Rustを触ってみて感じたこと&lt;/h2>
&lt;p>Rustを触る前に持っていた印象は「コンパイルが通りずらく、安全性が高い」「関数型っぽい」という感じだった。&lt;/p>
&lt;p>実際に学んでみた印象は次のような感じ。&lt;/p>
&lt;ul>
&lt;li>関数型っぽい書き心地
&lt;ul>
&lt;li>特にenumとパターンマッチング,Option型 ,Result型, 式指向な考え方などの関数型っぽい言語機能や極力データをイミュータブルに扱う思想などが心地よかった。筆者が大好きな言語であるElm(ウェブブラウザベースのGUIを作成するための純粋関数型)の好きな部分をほとんど含んでたのでElmに近い感覚で書くことができた。(もちろん慣れてないこともあってElmよりも全然難しかったけど)&lt;/li>
&lt;li>(Elmが気になる方は&lt;a href="https://guide.elm-lang.jp/">Elm Guide&lt;/a>がおすすめです)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>↑に近いがNull安全なことに加えて所有権などの概念のおかげでコンパイルが通りさえすればちゃんと動いてくれるという安心感がある。
&lt;ul>
&lt;li>リファクタもやりやすそう。(enumにバリアントを追加したとき、パターンマッチの全箇所を修正しないとコンパイルが通らなかったりすると思うので)&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>開発体験が良い
&lt;ul>
&lt;li>エラーメッセージがとても丁寧。「ここがこう悪いで〜」とか「ここをこう直すとええで〜」みたいなことまでエラーメッセージに書いてくれてあるホスピタリティに感動した。こういったところもRustが生産性が高いと言われる所以なのかもしれない。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>コミュニティの初学者をサポートする姿勢がすごい
&lt;ul>
&lt;li>RustのOSSプロジェクトへのcontributionについては &lt;a href="https://zenn.dev/fraternite/articles/4e11063bf05aac">rust-lang/rustへのcode contributionをはじめからていねいに&lt;/a> が詳しいが、Rust製のOSSプロジェクトには&lt;code>E-mentor&lt;/code>というタグがありissueを進めるに当たってメンターが指針を記してくれているらしい。（&lt;a href="https://github.com/rust-lang/rust/issues/109099">https://github.com/rust-lang/rust/issues/109099&lt;/a> これとかすごい。）&lt;/li>
&lt;li>いつかRustのOSSプロジェクトにもcontributionしてみたい&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>他の言語と比べて動くものをつくるまでに必要な学習コストは高いとは思うがRustをちゃんと書けるようになれば生産性高く安全なコードが書けると思うので必ずしも学習コストが高いとは言えないのかもしれない。（他の言語でも安全なコードを書くためには一定の学習や経験が必要だろうし）（※想像で喋っています）&lt;/li>
&lt;/ul>
&lt;p>総じて開発体験は良かったのでこれからもゆるゆるとRustの学習は続けていきたい。&lt;/p>
&lt;h2 id="余談">余談&lt;/h2>
&lt;p>テスト実行に &lt;a href="nextest-rs/nextest">https://github.com/nextest-rs/nextest&lt;/a> を使ってみたがテスト結果が見やすくて便利だった。&lt;/p>
&lt;p>&lt;code>cargo run&lt;/code>の結果
&lt;img src="cargo-run.png" alt="cargo run">&lt;/p>
&lt;p>&lt;code>cargo nextest run&lt;/code>の結果
&lt;img src="nextest-run.png" alt="cargo nextest run">&lt;/p>
&lt;p>カラフルで見やすい。&lt;/p></content></item><item><title>yamlに定義したbookmarkをfzfで選択してブラウザで開くくんを作った</title><link>https://blog.kyu08.com/posts/fzf-bookmark-opener/</link><pubDate>Thu, 23 Feb 2023 01:15:48 +0900</pubDate><guid>https://blog.kyu08.com/posts/fzf-bookmark-opener/</guid><description>つくったもの yamlに定義しておいたbookmarkをfzfで選択してブラウザで開くくんを作った。 https://github.com/kyu08/fzf-bookmark-opener こんな感じで動く。 コードの話 コード自体は</description><content>&lt;h2 id="つくったもの">つくったもの&lt;/h2>
&lt;p>yamlに定義しておいたbookmarkをfzfで選択してブラウザで開くくんを作った。&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/fzf-bookmark-opener">https://github.com/kyu08/fzf-bookmark-opener&lt;/a>&lt;/p>
&lt;p>こんな感じで動く。&lt;/p>
&lt;p>&lt;img src="https://user-images.githubusercontent.com/49891479/218272272-e693c10d-c810-458a-bf46-9c3a4a2fe45a.gif" alt="demo">&lt;/p>
&lt;h2 id="コードの話">コードの話&lt;/h2>
&lt;p>コード自体は大変シンプルで&lt;/p>
&lt;ol>
&lt;li>設定ファイルがなければ&lt;code>~/.config/fzf-bookmark-opener/config.yaml&lt;/code>に作成&lt;/li>
&lt;li>設定ファイルの読み込み&lt;/li>
&lt;li>fzfで選択&lt;/li>
&lt;li>選択されたブックマークをブラウザで開く&lt;/li>
&lt;/ol>
&lt;p>ということをやっているだけである。(&lt;code>main.go&lt;/code>に120行弱だけという素朴なコード量)&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/fzf-bookmark-opener/blob/69313bf187dcfd6127efcf75e172a34fb9b8e05a/main.go#L38-L60">fzf-bookmark-opener/main.go at main · kyu08/fzf-bookmark-opener&lt;/a>&lt;/p>
&lt;p>この記述量で作れたのは間違いなくktr0731/go-fuzzyfinderのおかげでした。このライブラリのおかげでgoのコードからfzfを簡単に呼び出すことができました。というかなんならこのライブラリの存在を知ったので使ってみたくなってfzf-bookmark-openerを作ったみたいなとこもあります。ありがとうございます。&lt;/p>
&lt;p>&lt;a href="https://github.com/ktr0731/go-fuzzyfinder">ktr0731/go-fuzzyfinder&lt;/a>&lt;/p>
&lt;h2 id="ちゃっかりbrewでも公開してみた">ちゃっかりbrewでも公開してみた&lt;/h2>
&lt;p>brewでインストールできるに越したことはないだろうってことで、brewでも公開してみたが思いのほか簡単だった。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>brew tap kyu08/tap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>brew install kyu08/tap/fzf-bookmark-opener
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これだけでインストールできるので気になった方もそうでない方もぜひ。issueやPRもお待ちしています。(&lt;code>go install&lt;/code>でインストールしたい方はこちら(&lt;code>go install github.com/kyu08/fzf-bookmark-opener@latest&lt;/code>))&lt;/p>
&lt;p>brew公開に関してはこちらのブログを参考にしたら30分弱でサクッと公開できた(想像より簡単だった)&lt;/p>
&lt;p>&lt;a href="https://www.rasukarusan.com/entry/2019/11/03/211338">https://www.rasukarusan.com/entry/2019/11/03/211338&lt;/a>&lt;/p>
&lt;p>詳細は↑の記事を読んでいただければわかるが、リリースにバイナリを含めて配布用のrepositoryを作るだけなので本当に簡単だったのでツールを配布したい人はぜひ。&lt;/p>
&lt;h2 id="ちゃっかりヘルパースクリプトも公開した">ちゃっかりヘルパースクリプトも公開した&lt;/h2>
&lt;p>現在お仕事ではGCPを使っているんですが、GCPのコンソールをプロジェクト、サービスを指定して直接開きたいことが多いのでプロジェクトのリストを渡すとGCPの主要なサービス(主観)のURL一覧をfzf-bookmark-openerの設定ファイルの形式で吐いてくれるスクリプトも公開した。&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/gcp-url-generator">kyu08/gcp-url-generator&lt;/a>&lt;/p>
&lt;p>project名のリストとregionを渡すとこういう文字列を吐いてくれるイメージ。(以下は出力の一部)(この例だとregionは関係ない)&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-yaml" data-lang="yaml">&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Home stg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://console.cloud.google.com/home/dashboard?project=stg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Home dev&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://console.cloud.google.com/home/dashboard?project=dev&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Home prod&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://console.cloud.google.com/home/dashboard?project=prod&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Datastore stg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://console.cloud.google.com/datastore/entities?project=stg&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Datastore dev&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://console.cloud.google.com/datastore/entities?project=dev&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - &lt;span style="color:#f92672">title&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;Datastore prod&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#f92672">url&lt;/span>: &lt;span style="color:#e6db74">&amp;#39;https://console.cloud.google.com/datastore/entities?project=prod&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>現在の対応サービスは以下で、Cloud Runに関してはサービス名の配列を渡すとプロジェクト*サービスの全組み合わせのURLを吐く。&lt;/p>
&lt;ul>
&lt;li>Dashboard&lt;/li>
&lt;li>Datastore&lt;/li>
&lt;li>App Engine&lt;/li>
&lt;li>Artifact Registry&lt;/li>
&lt;li>Cloud Storage&lt;/li>
&lt;li>Spanner&lt;/li>
&lt;li>BigQuery&lt;/li>
&lt;li>Cloud Scheduler&lt;/li>
&lt;li>PubSub&lt;/li>
&lt;li>Dataflow&lt;/li>
&lt;li>Cloud Build&lt;/li>
&lt;li>Cloud Tasks&lt;/li>
&lt;li>Cloud Run&lt;/li>
&lt;li>Cloud SQL&lt;/li>
&lt;li>Cloud Functions&lt;/li>
&lt;li>IAM&lt;/li>
&lt;li>Secret Manager&lt;/li>
&lt;li>AI Platform&lt;/li>
&lt;li>Compute Engine&lt;/li>
&lt;li>Logging&lt;/li>
&lt;li>Monitoring&lt;/li>
&lt;li>Workflows&lt;/li>
&lt;li>Firebase Realtime Database (DB)&lt;/li>
&lt;li>Firebase Hosting&lt;/li>
&lt;li>Firebase Remote Config&lt;/li>
&lt;/ul>
&lt;p>これで生成したURLをfzf-bookmark-openerに食わせるとお使いのGCPプロジェクトの特定のサービスがコマンドラインからサクッと開くことができる。(詳しくは&lt;a href="https://github.com/kyu08/gcp-url-generator">kyu08/gcp-url-generatorのREADME&lt;/a>を参照)
こちらもissueやPRお待ちしてます。&lt;/p>
&lt;h2 id="余談1">余談1&lt;/h2>
&lt;p>Rustだとlotabout/skimを使うとktr0731/go-fuzzyfinderと同じようなことができるらしい。最近Rust熱が高まりに高まっている(Tour of Rustやり中)ので次に何かCLIでfzfなツールをつくるときは使ってみようと思う。&lt;/p>
&lt;p>&lt;a href="https://github.com/lotabout/skim">lotabout/skim&lt;/a>&lt;/p>
&lt;p>[追記]
Makefileに定義されたtargetをfzfで選択して実行するCLIツールをRustでつくった。&lt;/p>
&lt;p>&lt;a href="https://github.com/kyu08/fzf-make">kyu08/fzf-make&lt;/a>&lt;/p>
&lt;h2 id="余談2">余談2&lt;/h2>
&lt;p>ふと気になってktr0731/go-fuzzyfinderをはじめとする依存ライブラリのライセンス表示はどうすればいいか気になって調べてみたところリポジトリに&lt;code>NOTICES&lt;/code>とか&lt;code>CREDITS&lt;/code>とか&lt;code>ThirdPartyNotices&lt;/code>みたいなファイルを置いてそこに依存ライブラリの著作権・ライセンス表示をするのが一般的なようだった。&lt;/p>
&lt;p>手作業でやるのは辛いので自動生成ツールを探したところGoだとこれが使いやすそうだったので使ってみたけど簡単でとてもよかった。ありがたや&amp;hellip;。&lt;/p>
&lt;p>&lt;a href="https://github.com/Songmu/gocredits">https://github.com/Songmu/gocredits&lt;/a>&lt;/p>
&lt;h2 id="まとめ">まとめ&lt;/h2>
&lt;p>ktr0731/go-fuzzyfinderはいいぞ〜&lt;/p></content></item><item><title>Tmux+NeovimでJetBrains IDEのScratchみたいな機能を実現している話</title><link>https://blog.kyu08.com/posts/tmux-neovim-scratch/</link><pubDate>Sun, 05 Feb 2023 01:15:48 +0900</pubDate><guid>https://blog.kyu08.com/posts/tmux-neovim-scratch/</guid><description>任意の構成のSandbox的な環境をTmuxのwindowとして用意するようにしたところターミナルから出ずにサクっと動作検証とかが行えてハッ</description><content>&lt;p>任意の構成のSandbox的な環境をTmuxのwindowとして用意するようにしたところターミナルから出ずにサクっと動作検証とかが行えてハッピーになったよ、という記事。ここではvanillaなGoのプロジェクトの例を紹介しますが、お好みの構成でSandbox環境を作ってみてください。&lt;/p>
&lt;p>全然大したことをやっているわけではないですがTmux, Neovimやそれらのプラグインの普及活動になれば嬉しいので書いてみます。&lt;/p>
&lt;h2 id="動作イメージ">動作イメージ&lt;/h2>
&lt;p>こんな感じでvanillaのGoプロジェクトをTmuxのwindowに開いておいて、確認したくなったときにすぐwindowを切り替えてコードを書いて実行結果を確認できるようにしている。(Gifの例はGoの書式指定子&lt;code>%+v&lt;/code>の動作を忘れて試してみているところ)&lt;/p>
&lt;p>&lt;img src="go-playground.gif" alt="go-playground">&lt;/p>
&lt;p>Gifでやっていることは以下&lt;/p>
&lt;ol>
&lt;li>GoのSandbox環境を開いたNeovimが起動しているwindowに切り替え&lt;/li>
&lt;li>コードを書く&lt;/li>
&lt;li>Neovim上でターミナルを表示&lt;/li>
&lt;li>&lt;code>make run&lt;/code>を実行してコード実行&lt;/li>
&lt;li>結果を確認&lt;/li>
&lt;li>元いたwindowに戻る&lt;/li>
&lt;/ol>
&lt;p>tmux-fzfなど筆者のターミナル環境については以下参照&lt;/p>
&lt;p>&lt;a href="https://blog.kyu08.com/posts/my-dev-setup-terminal">開発の効率化のためにやっていること ターミナル編&lt;/a>&lt;/p>
&lt;p>筆者はGoの動作を確認したいことがほとんどなのでこういった構成にしているが、必要に応じてよく使うFWをセットアップした環境を作っておくと便利そう。&lt;/p>
&lt;h2 id="プロジェクトの内容">プロジェクトの内容&lt;/h2>
&lt;p>Go固有の内容もあるので参考程度で。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-bash" data-lang="bash">&lt;span style="display:flex;">&lt;span>├── .git
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── .gitignore
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── go.mod
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── go.sum
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── main.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── main.go.sample
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>├── main_test.go
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>└── Makefile
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>基本的に&lt;code>main.go&lt;/code>の中身を編集して、&lt;code>go run .&lt;/code>で実行して実行結果を確認するということをしている。&lt;/p>
&lt;p>&lt;code>Makefile&lt;/code>の中身は以下のような感じになっていて、&lt;code>make run&lt;/code>でコード実行、&lt;code>make clear&lt;/code>で&lt;code>main.go&lt;/code>をまっさらにできるようにしているだけである。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-Makefile" data-lang="Makefile">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">.PHONY&lt;/span>&lt;span style="color:#f92672">:&lt;/span> run clear
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">run&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @go run .
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">clear&lt;/span>&lt;span style="color:#f92672">:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> @cp ./main.go.sample ./main.go
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>main.go.sample&lt;/code>の内容は以下。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-go" data-lang="go">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">package&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">func&lt;/span> &lt;span style="color:#a6e22e">main&lt;/span>() {
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>}
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>あとはよく見返したくなるコードは&lt;code>main.go&lt;/code>以外のファイル名で保存したり、commitしておくと後からでもさっと確認できてよさそう。(筆者はそこまでやってない)&lt;/p>
&lt;h2 id="感想">感想&lt;/h2>
&lt;p>ターミナルから出ずに作業が完結できてうれしい。&lt;/p>
&lt;p>同様のことはGoの場合はブラウザからThe Go Playground(※)を開いても行えるが筆者は何でもターミナルでできると嬉しい人なのでできるようにしてみた。&lt;/p>
&lt;p>※ブラウザ上で実行できるGoのエディタ + 実行環境がセットになったやつ。&lt;a href="https://go.dev/play/">https://go.dev/play/&lt;/a>&lt;/p>
&lt;p>あとやるとしたらThe Go PlaygroundにあるURL発行機能とかを実現できると他の人への共有も楽になっていいのかもしれない。(今のところあんまり他の人に共有する機会がないので困っていない)&lt;/p>
&lt;h2 id="補足">補足&lt;/h2>
&lt;p>最後に補足としてGif内で使っているNeovimのプラグインを紹介します。&lt;/p>
&lt;h3 id="ターミナル表示">ターミナル表示&lt;/h3>
&lt;p>&lt;a href="https://github.com/voldikss/vim-floaterm">voldikss/vim-floaterm&lt;/a>&lt;/p>
&lt;p>&lt;img src="floaterm.gif" alt="floaterm">&lt;/p>
&lt;p>GoのSandbox環境の&lt;code>main.go&lt;/code>に書いたスクリプトを実行するために、Neovimからターミナルを表示するシーンで使っている。&lt;/p>
&lt;p>コード編集してサクっと動作確認したいときなどに便利。(といいつつ最近動作の重さが目立ってきたので&lt;code>&amp;lt;C-z&amp;gt;&lt;/code>でNeovimの起動元に戻ってターミナルを操作することが多い)&lt;/p>
&lt;h3 id="カーソル移動">カーソル移動&lt;/h3>
&lt;p>&lt;a href="https://github.com/yuki-yano/fuzzy-motion.vim">yuki-yano/fuzzy-motion.vim&lt;/a>&lt;/p>
&lt;p>&lt;code>fmt.Printf(&amp;quot;u: %v\n&amp;quot;, u)&lt;/code>の&lt;code>u&lt;/code>から&lt;code>%v&lt;/code>の位置にカーソル移動する際に使っているプラグイン。&lt;/p>
&lt;p>動作のイメージはこんな感じ。&lt;/p>
&lt;p>&lt;img src="fuzzy-motion.gif" alt="fuzzy-motion">&lt;/p>
&lt;p>起動すると文字がグレーアウトするのでジャンプしたい文字列を入力するとその文字にジャンプするためのキーワードを表示してくれるというプラグイン。&lt;/p>
&lt;p>同様の機能をもつプラグインとしてはeasy-motionなどのプラグインが有名だが、fuzzy-motionはジャンプしたい文字列をfuzzy-finder形式で絞り込んでくれるのが大きな特徴。(詳しくはリポジトリのREADME参照)&lt;/p>
&lt;p>筆者はノーマルモードで&lt;code>f&lt;/code>キーを押下するとプラグインが起動するように設定している。&lt;/p>
&lt;p>カーソル移動の効率がよすぎて正直もうこれなしでは開発したくない。&lt;/p>
&lt;h3 id="lsp-server">LSP Server&lt;/h3>
&lt;p>&lt;a href="https://github.com/neoclide/coc.nvim">neoclide/coc.nvim&lt;/a>&lt;/p>
&lt;p>Language Serverをホストするためのプラグイン。&lt;/p>
&lt;p>すごく簡単にいうと補完や関数定義を表示したり定義ジャンプできるようにしたりしてくれる。&lt;/p>
&lt;p>&lt;img src="coc-nvim.gif" alt="coc-nvim">&lt;/p>
&lt;p>以上です。ここまで読んでくれてありがとうございました。&lt;/p></content></item><item><title>開発の効率化のためにやっていること ターミナル編</title><link>https://blog.kyu08.com/posts/my-dev-setup-terminal/</link><pubDate>Thu, 15 Dec 2022 01:15:48 +0900</pubDate><guid>https://blog.kyu08.com/posts/my-dev-setup-terminal/</guid><description>【この記事はUnipos Advent Calendar 2022の記事です】 この記事では筆者が開発の効率化のために行っている工夫や使っているツールなどについて紹介します</description><content>&lt;p>【この記事は&lt;a href="https://qiita.com/advent-calendar/2022/unipos">Unipos Advent Calendar 2022&lt;/a>の記事です】&lt;/p>
&lt;p>この記事では筆者が開発の効率化のために行っている工夫や使っているツールなどについて紹介します。
「他にもこんなツールあるよ！」「こんな設定おすすめだよ！」などなどありましたらtwitterとかで教えてもらえると助かります。&lt;/p>
&lt;p>今回はターミナル編です！&lt;/p>
&lt;h2 id="シェル">シェル&lt;/h2>
&lt;p>シェルはzshを使っています。 一時期fishも使っていましたが、環境移行のコストが低かったりPOSIX準拠だったりするメリットに旨味を感じてzshに乗り換えました。&lt;/p>
&lt;h3 id="よく使うalias">よく使うalias&lt;/h3>
&lt;p>zshでは&lt;code>alias hoge='echo hoge'&lt;/code>のように記述することでaliasを定義することができます。&lt;/p>
&lt;p>ここでは筆者がよく使うaliasをいくつか紹介します。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="display:flex;">&lt;span>alias m&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;MEMODIR=~/code/memo; cd $MEMODIR; FILE=$MEMODIR/$(date +%Y%m%d).md; if [ ! -e $FILE ]; then echo &amp;#34;# todo \n\n# done\n&amp;#34; &amp;gt;&amp;gt; $FILE; fi; nvim $FILE&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>日毎に&lt;code>yyyymmdd.md&lt;/code>形式の名前のファイルを作成してvimで開く。
ファイルが存在していなければ&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span># todo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># done
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>をファイルに書き込んだうえでvimで開く、という内容のワンライナーです。&lt;/p>
&lt;p>実際に呼び出すとこんな感じです。&lt;/p>
&lt;p>&lt;img src="memo.gif" alt="memo">&lt;/p>
&lt;p>ちなみに筆者は&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span># todo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">-&lt;/span> タスクA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">-&lt;/span> 子タスクa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">-&lt;/span> 子タスクb
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">-&lt;/span> タスクB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># done
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>のような感じでタスクを書いていき、完了したら以下のように&lt;code>done&lt;/code>に移すという素朴な方法でタスク管理をしています。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-md" data-lang="md">&lt;span style="display:flex;">&lt;span># todo
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">-&lt;/span> タスクB
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span># done
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">-&lt;/span> タスクA
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">-&lt;/span> 子タスクa
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">-&lt;/span> 子タスクb
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="display:flex;">&lt;span>alias ghw&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;gh repo view -w&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>gh&lt;/code>コマンドを利用して現在いるリポジトリをブラウザでGitHubで開くコマンド&lt;/p>
&lt;p>&lt;img src="ghw.gif" alt="ghw">&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="display:flex;">&lt;span>alias pbc&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;pbcopy &amp;amp;&amp;amp; pbpaste&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;code>make test | pbc&lt;/code>のように出力をパイプで&lt;code>pbc&lt;/code>に渡すとクリップボードにコピーしつつ標準出力に出力してくれる。&lt;/p>
&lt;p>コマンドの出力をコピーしたいけど出力内容もその場で確認したいときに便利。&lt;/p>
&lt;p>こちらの記事で紹介されていた。&lt;/p>
&lt;p>&lt;a href="https://takuya-1st.hatenablog.jp/entry/2017/05/30/093000">https://takuya-1st.hatenablog.jp/entry/2017/05/30/093000&lt;/a>&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="display:flex;">&lt;span>alias finder&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;open -a Finder ./&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>現在いるディレクトをfinderで開くコマンド&lt;/p>
&lt;p>ごく稀に使う。&lt;/p>
&lt;h3 id="ディレクトリ移動">ディレクトリ移動&lt;/h3>
&lt;p>zshにはcdrという、移動したことがあるディレクトリを自動的に保持してくれる機能があります。&lt;/p>
&lt;p>これをいい感じにファジーファインダーから呼び出すスクリプトを公開して下さっている方がいたのでありがたく使わせてもらっています。&lt;/p>
&lt;p>&lt;a href="https://www.rasukarusan.com/entry/2018/08/14/083000">https://www.rasukarusan.com/entry/2018/08/14/083000&lt;/a>&lt;/p>
&lt;p>fzfをインストールした上で以下のスクリプトを&lt;code>.zshrc&lt;/code>に記述すると&lt;code>c&lt;/code>で呼び出すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># fzf-cdr &lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>alias c&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;fzf-cdr&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> fzf-cdr&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>cdr -l | sed &lt;span style="color:#e6db74">&amp;#39;s/^[^ ][^ ]* *//&amp;#39;&lt;/span> | fzf&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> target_dir&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>echo &lt;span style="color:#e6db74">${&lt;/span>target_dir/&lt;span style="color:#ae81ff">\~&lt;/span>/$HOME&lt;span style="color:#e6db74">}&lt;/span>&lt;span style="color:#e6db74">`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">[&lt;/span> -n &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$target_dir&lt;span style="color:#e6db74">&amp;#34;&lt;/span> &lt;span style="color:#f92672">]&lt;/span>; &lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cd $target_dir
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># cdrの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>autoload -Uz is-at-least
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> is-at-least 4.3.11
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">then&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> autoload -Uz chpwd_recent_dirs cdr add-zsh-hook
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> add-zsh-hook chpwd chpwd_recent_dirs
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zstyle &lt;span style="color:#e6db74">&amp;#39;:chpwd:*&amp;#39;&lt;/span> recent-dirs-max &lt;span style="color:#ae81ff">500&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zstyle &lt;span style="color:#e6db74">&amp;#39;:chpwd:*&amp;#39;&lt;/span> recent-dirs-default yes
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> zstyle &lt;span style="color:#e6db74">&amp;#39;:completion:*&amp;#39;&lt;/span> recent-dirs-insert both
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">fi&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># fzfの設定&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>export FZF_DEFAULT_OPTS&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#39;--color=fg+:11 --height 70% --reverse --exit-0 --multi&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>これを実際に使うとこんな感じになります。ファジーファインダーを利用して効率的にディレクトリ移動することができます。&lt;/p>
&lt;p>&lt;img src="fzf-cdr.gif" alt="cdr">&lt;/p>
&lt;p>やっていることは以下です。&lt;/p>
&lt;ol>
&lt;li>&lt;code>.zshrc&lt;/code>に定義したfzf-cdrを実行&lt;/li>
&lt;li>移動したいディレクトリのパスの一部を入力&lt;/li>
&lt;li>候補から移動したいディレクトリを選択する&lt;/li>
&lt;/ol>
&lt;h3 id="コマンド履歴検索">コマンド履歴検索&lt;/h3>
&lt;p>実行したコマンドの履歴についてもfzfを使って絞り込みを行うようにしています。&lt;/p>
&lt;p>これもスクリプトを公開して下さっている方がいたのでありがたく使わせてもらっています。&lt;/p>
&lt;p>&lt;a href="https://techblog.sgr-ksmt.dev/2016/12/10/smart_fzf_history/">https://techblog.sgr-ksmt.dev/2016/12/10/smart_fzf_history/&lt;/a>&lt;/p>
&lt;p>以下のスクリプトを&lt;code>.zshrc&lt;/code>に記述すると、&lt;code>ctrl + r&lt;/code>でコマンド履歴を呼び出すことができます。&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-zsh" data-lang="zsh">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">function&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span>-history&lt;span style="color:#f92672">()&lt;/span> &lt;span style="color:#f92672">{&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> BUFFER&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">$(&lt;/span>history -n -r &lt;span style="color:#ae81ff">1&lt;/span> | fzf --no-sort +m --query &lt;span style="color:#e6db74">&amp;#34;&lt;/span>$LBUFFER&lt;span style="color:#e6db74">&amp;#34;&lt;/span> --prompt&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#e6db74">&amp;#34;History &amp;gt; &amp;#34;&lt;/span>&lt;span style="color:#66d9ef">)&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> CURSOR&lt;span style="color:#f92672">=&lt;/span>$#BUFFER
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">}&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>zle -N &lt;span style="color:#66d9ef">select&lt;/span>-history
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>bindkey &lt;span style="color:#e6db74">&amp;#39;^r&amp;#39;&lt;/span> &lt;span style="color:#66d9ef">select&lt;/span>-history
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>&lt;img src="command-history.gif" alt="command-history">&lt;/p>
&lt;h2 id="git操作">Git操作&lt;/h2>
&lt;p>Git操作のほとんどはGitのTUIクライアントであるLazygitを使っています。&lt;/p>
&lt;p>&lt;a href="https://github.com/jesseduffield/lazygit">https://github.com/jesseduffield/lazygit&lt;/a>&lt;/p>
&lt;p>Lazygitはターミナル上で動作するリッチなGitクライアントでGitに関する大抵のことを行うことができます。(機能が豊富すぎて何ができて何ができないのかを正確に把握できていない)&lt;/p>
&lt;p>以下はLazygitを使って変更をaddしてcommitしてpushする例です。&lt;/p>
&lt;p>&lt;img src="lazygit-push.gif" alt="lazygit-push">&lt;/p>
&lt;p>見やすいですし、&lt;strong>少ないタイプ数で操作できる&lt;/strong>点でおすすめです。他にも基本的なブランチ操作はもちろんのこと、&lt;code>git rebase -i&lt;/code>相当のこともスピーディーにできるのでよく使っています。&lt;/p>
&lt;p>ちなみに筆者はkdheepak/lazygit.nvimというプラグインを使ってNeovim上からLazygitを呼び出しています。&lt;/p>
&lt;p>&lt;a href="https://github.com/kdheepak/lazygit.nvim">https://github.com/kdheepak/lazygit.nvim&lt;/a>&lt;/p>
&lt;h2 id="ターミナルエミュレータ">ターミナルエミュレータ&lt;/h2>
&lt;p>筆者はターミナルエミュレータ(以下ターミナル)としてAlacrittyを使っています。&lt;/p>
&lt;p>&lt;a href="https://github.com/alacritty/alacritty">https://github.com/alacritty/alacritty&lt;/a>&lt;/p>
&lt;p>筆者は普段開発にNeovimを利用しているのですが、以前からプロジェクトの全文検索に時間がかかってしまう点が気になっていました。
動作が高速なターミナルを探していたところRust製のターミナルであるAlacrittyにたどり着きました。&lt;/p>
&lt;p>iTerm2からの乗り換えでしたが満足できるだけの速度になりました。&lt;strong>ターミナルの速度を早くしたい人にはオススメ&lt;/strong>です。あとは&lt;strong>設定をyamlで記述できる&lt;/strong>のも好みなポイントです。&lt;/p>
&lt;p>カラースキームはTokyo Nightを利用しています。&lt;/p>
&lt;p>&lt;a href="https://github.com/zatchheems/tokyo-night-alacritty-theme">https://github.com/zatchheems/tokyo-night-alacritty-theme&lt;/a>&lt;/p>
&lt;p>&lt;img src="tokyonight.png" alt="tokyonight">&lt;/p>
&lt;p>Alacrittyにはタブ機能がなくタブ的な機能を実現するためにはtmuxなどのターミナルマルチプレクサを利用する必要があるため筆者はtmuxを利用しています。
設定・プラグインなどは後述しますが、tmuxの操作感も好みなので割と満足しています。&lt;/p>
&lt;p>他にもRust製のターミナルとしてWarp, Weztermなどがありますが筆者の環境ではWarpはNeovimのcolorschemeの反映がうまくできず、Weztermは画面の再描画まわりの不具合が多少あったため、採用しませんでした。(Warp便利そうだしみやすいので使いたかった)&lt;/p>
&lt;h2 id="ターミナルのタブ管理">ターミナルのタブ管理&lt;/h2>
&lt;p>前述の通りAlacrittyにはタブ機能がないため、tmuxを使ってターミナルのタブ管理を行っています。&lt;/p>
&lt;p>&lt;a href="https://github.com/tmux/tmux">https://github.com/tmux/tmux&lt;/a>&lt;/p>
&lt;h3 id="ステータスラインの表示">ステータスラインの表示&lt;/h3>
&lt;p>ステータスラインは比較的シンプルにしていて、&lt;/p>
&lt;ul>
&lt;li>ウィンドウ一覧&lt;/li>
&lt;li>現在時刻&lt;/li>
&lt;/ul>
&lt;p>を表示するようにしています。&lt;/p>
&lt;p>&lt;img src="tmux-status-line.png" alt="tmux-status-line">&lt;/p>
&lt;p>普段の開発ではプロジェクトごとにウィンドウを開き、必要に応じて切り替える運用にしています。&lt;/p>
&lt;h3 id="ウィンドウの切り替え">ウィンドウの切り替え&lt;/h3>
&lt;p>筆者はふだんプロジェクトごとのウィンドウに加えてmemo用のウィンドウ・dotfiles用のウィンドウなども開いており、常時ウィンドウが15前後あります。筆者は簡単なタスク管理もmemo用ウィンドウに立ち上げたNeovim内で行っているため、ウィンドウの切り替えを頻繁に行います。&lt;/p>
&lt;p>以前まではウィンドウ切り替えを&lt;/p>
&lt;ol>
&lt;li>&lt;code>prefix + w&lt;/code> でウィンドウの一覧を表示&lt;/li>
&lt;li>目的のウィンドウの位置を確認&lt;/li>
&lt;li>目的のウィンドウまで &lt;code>ctrl + n&lt;/code>, &lt;code>ctrl + p&lt;/code> で移動&lt;/li>
&lt;li>選択する&lt;/li>
&lt;/ol>
&lt;p>という手順で行っていましたがウィンドウが増えてくると地味にウィンドウ移動が大変になっていきました。以下は従来のウィンドウ切り替えの様子です。&lt;/p>
&lt;p>&lt;img src="tmux-window.gif" alt="tmux-window">&lt;/p>
&lt;p>どうにかもう少し楽にウィンドウ切り替えをできないかと探していたところsainnhe/tmux-fzfに出会いました。&lt;/p>
&lt;p>&lt;a href="https://github.com/sainnhe/tmux-fzf">https://github.com/sainnhe/tmux-fzf&lt;/a>&lt;/p>
&lt;p>sainnhe/tmux-fzfはファジーファインダーで効率的にtmuxを操作するためのプラグインです。&lt;/p>
&lt;p>詳しくはリポジトリのREADMEに譲りますが、&lt;/p>
&lt;ul>
&lt;li>セッション管理&lt;/li>
&lt;li>ウィンドウ管理&lt;/li>
&lt;li>ペイン管理&lt;/li>
&lt;li>コマンドの検索&lt;/li>
&lt;/ul>
&lt;p>などが可能です。&lt;/p>
&lt;p>筆者はウィンドウ管理機能の中のウィンドウの切り替え機能を使っています。
sainnhe/tmux-fzf を使うようにしたことでウィンドウ切り替えを&lt;/p>
&lt;ol>
&lt;li>&lt;code>prefix&lt;/code> + &lt;code>prefix&lt;/code> でtmux-fzfのウィンドウ一覧を表示&lt;/li>
&lt;li>目的のウィンドウ名の一部を入力&lt;/li>
&lt;li>選択する&lt;/li>
&lt;/ol>
&lt;p>という手順でできるようになりました。文字にすると違いが伝わりづらいですが、ファジーファインダーを使ってウィンドウの選択を行うことができるようになったことでキーのタイプ数や切り替えの際の脳の負荷を大幅に減らすことができました。&lt;/p>
&lt;p>&lt;img src="tmux-fzf.gif" alt="tmux-fzf">&lt;/p>
&lt;h2 id="おわりに">おわりに&lt;/h2>
&lt;p>ここまで読んでくださってありがとうございました。&lt;/p>
&lt;p>需要がありそうだったら&lt;/p>
&lt;ul>
&lt;li>Neovim編&lt;/li>
&lt;li>alfred編&lt;/li>
&lt;li>chrome拡張機能編&lt;/li>
&lt;/ul>
&lt;p>なども書こうと思います。&lt;/p></content></item></channel></rss>